# _MAPTRIANGLE

The _MAPTRIANGLE statement maps a triangular portion of an image onto a destination image or screen page.

  

## Syntax

### 2D drawing

_MAPTRIANGLE [{_SEAMLESS}] **(***sx1***,** *sy1***)-(***sx2***,** *sy2***)-(***sx3***,** *sy3***),** *source&* **TO (***dx1***,** *dy1***)-(***dx2***,** *dy2***)-(***dx3***,** *dy3***)**[, *destination&*][,{_SMOOTH|_SMOOTHSHRUNK|_SMOOTHSTRETCHED}
### 3D drawing (hardware images only)

_MAPTRIANGLE [{_CLOCKWISE|_ANTICLOCKWISE}] [{_SEAMLESS}] **(***sx1***,** *sy1***)-(***sx2***,** *sy2***)-(***sx3***,** *sy3***),** *source&* **TO (***dx1***,** *dy1***,** *dz1***)-(***dx2***,** *dy2***,** *dz2***)-(***dx3***,** *dy3***,** *dz3***)**[, *destination&*][,{_SMOOTH|_SMOOTHSHRUNK|_SMOOTHSTRETCHED}
  

## Parameters

* The **_SEAMLESS** option makes the triangle skip the right-most and bottom-most pixels of the triangle. When you make larger objects using several triangles, there can be a "seam" where they overlap when using alpha transparency and the seam would be twice as bright. **_SEAMLESS** is ignored when rendering 3D content and is not yet supported when drawing 2D hardware images.
* For 3D drawing use the **_CLOCKWISE** and **_ANTICLOCKWISE** arguments to only draw triangles in the correct direction. See *Example 4*.
* Coordinates are [SINGLE](,{_SMOOTH|_SMOOTHSHRUNK|_SMOOTHSTRETCHED}
  

## Parameters

* The **_SEAMLESS** option makes the triangle skip the right-most and bottom-most pixels of the triangle. When you make larger objects using several triangles, there can be a "seam" where they overlap when using alpha transparency and the seam would be twice as bright. **_SEAMLESS** is ignored when rendering 3D content and is not yet supported when drawing 2D hardware images.
* For 3D drawing use the **_CLOCKWISE** and **_ANTICLOCKWISE** arguments to only draw triangles in the correct direction. See *Example 4*.
* Coordinates are [SINGLE.md) values where whole numbers represent the exact center of a pixel of the source texture.
* *source&* and optional *destination&* are [LONG](LONG.md) image or screen page handles.
* Supports an optional final argument **_SMOOTH** which applies linear filtering. See *Example 3*.
* Use **_SMOOTHSTRETCHED** or **_SMOOTHSHRUNK** for when a pixelated/smooth effect is desirable but not both.

  

## Description

* This statement is used similar to [_PUTIMAGE](_PUTIMAGE.md) to place triangular sections of an image, but is more flexible.
* The [STEP](STEP.md) keyword can be used to for coordinates relative to the last graphic coordinates used.
* For 2D drawing, the destination coordinates are pixel coordinates either on-screen or on the destination image.
* For 3D drawing, the destination coordinates represent left (-x) to right (+x), bottom (-y) to top (+y) & furthest (-z) to nearest (z=-1). The center of the screen is therefore (0,0,-1). Note that a z value of 0 will result in off-screen content. The furthest visible z value is -10,000.
* When drawing **software images** coordinate positions are **limited from -16383 to 16383**
* The source coordinates can be positioned outside the boundary of the *source* image to achieve a tiled effect.
* If the *destination&* image handle is the current [SCREEN](SCREEN.md) page, [_DEST](_DEST.md) or hardware layer, then it can be omitted.
* **Hardware images** (created using mode 33 via [_LOADIMAGE](_LOADIMAGE.md) or [_COPYIMAGE](_COPYIMAGE.md)) can be used as the source or destination.

  

## Examples

*Example 1:* Rotating the an image using a rotation and zoom SUB with _MAPTRIANGLE.

``` [SCREEN](SCREEN.md) [_NEWIMAGE](_NEWIMAGE.md)(800, 600, 32)  Image& = [_LOADIMAGE](_LOADIMAGE.md)("qb64_trans.png")   'any 24/32 bit image  [DO](DO.md)   [CLS](CLS.md)   RotoZoom 400, 300, Image&, 1.5 + [SIN](SIN.md)(zoom), angle   [LOCATE](LOCATE.md) 1, 1: [PRINT](PRINT.md) "Angle:"; [CINT](CINT.md)(angle)   [PRINT](PRINT.md) "Zoom"; [USING](USING.md) "##.###"; 1.5 + [SIN](SIN.md)(zoom)   [_DISPLAY](_DISPLAY.md)   angle = angle + .5: [IF](IF.md) angle >= 360 [THEN](THEN.md) angle = angle - 360   zoom = zoom + .01 [LOOP](LOOP.md) [UNTIL](UNTIL.md) [INKEY$](INKEY$.md) <> "" [END](END.md)  [SUB](SUB.md) RotoZoom (X [AS](AS.md) [LONG](LONG.md), Y [AS](AS.md) [LONG](LONG.md), Image [AS](AS.md) [LONG](LONG.md), Scale [AS](AS.md) [SINGLE](SINGLE.md), Rotation [AS](AS.md) [SINGLE](SINGLE.md)) [DIM](DIM.md) px(3) [AS](AS.md) [SINGLE](SINGLE.md): [DIM](DIM.md) py(3) [AS](AS.md) [SINGLE](SINGLE.md) W& = [_WIDTH](_WIDTH.md) "WIDTH (function)")(Image&): H& = [_HEIGHT](_HEIGHT.md)(Image&) px(0) = -W& / 2: py(0) = -H& / 2: px(1) = -W& / 2:py(1) = H& / 2 px(2) = W& / 2: py(2) = H& / 2: px(3) = W& / 2: py(3) = -H& / 2 sinr! = [SIN](SIN.md)(-Rotation / 57.2957795131): cosr! = [COS](COS.md)(-Rotation / 57.2957795131) [FOR](FOR.md) i& = 0 [TO](TO.md) 3   x2& = (px(i&) * cosr! + sinr! * py(i&)) * Scale + X: y2& = (py(i&) * cosr! - px(i&) * sinr!) * Scale + Y   px(i&) = x2&: py(i&) = y2& [NEXT](NEXT.md) _MAPTRIANGLE (0, 0)-(0, H& - 1)-(W& - 1, H& - 1), Image& TO(px(0), py(0))-(px(1), py(1))-(px(2), py(2)) _MAPTRIANGLE (0, 0)-(W& - 1, 0)-(W& - 1, H& - 1), Image& TO(px(0), py(0))-(px(3), py(3))-(px(2), py(2)) [END SUB](END SUB.md)  
```

```         **Triangle sections of image in code above     __**                                                      **|\2|**                                                   **1→|_\|**  
```

  

*Example 2:* A 3D Spinning Cube demo using a software image and _MAPTRIANGLE:

``` ' Copyright (C) 2011 by Andrew L. Ayers  [DIM](DIM.md) OBJECT(9, 9, 4, 2) [AS](AS.md) [LONG](LONG.md)  ' OBJECTS DEFINED [AS](AS.md) FOLLOWS: '   (#OBJECTS,#PLANES PER OBJECT,#[POINT](POINT.md)S PER PLANE, XYZ TRIPLE)  [DIM](DIM.md) DPLANE2D(4, 1) [AS](AS.md) [LONG](LONG.md) ' [SCREEN](SCREEN.md) PLANE COORDINATES  ' DPLANE2D DEFINED [AS](AS.md) FOLLOWS: '   (#[POINT](POINT.md)S PER PLANE, XY [DOUBLE](DOUBLE.md))  [DIM](DIM.md) DPLANE3D(4, 2) [AS](AS.md) [LONG](LONG.md) ' 3D PLANE COORDINATES  ' DPLANE3D DEFINED [AS](AS.md) FOLLOWS: '   (#[POINT](POINT.md)S PER PLANE, XYZ TRIPLE)  [DIM](DIM.md) PLANECOL(9) [AS](AS.md) [INTEGER](INTEGER.md) [DIM](DIM.md) STAB(359), CTAB(359) ' SINE/COSINE TABLES D& = 400: MX& = 0: MY& = 0: MZ& = -100 ' ' COMPUTE SINE/COSINE TABLES [FOR](FOR.md) t& = 0 [TO](TO.md) 359   STAB(t&) = [SIN](SIN.md)((6.282 / 360) * t&)   CTAB(t&) = [COS](COS.md)((6.282 / 360) * t&) [NEXT](NEXT.md) ' ' BUILD CUBE IN OBJECT ARRAY ' PLANE 0 OBJECT(0, 0, 0, 0) = -30: OBJECT(0, 0, 0, 1) = 30: OBJECT(0, 0, 0, 2) = -30 OBJECT(0, 0, 1, 0) = -30: OBJECT(0, 0, 1, 1) = -30: OBJECT(0, 0, 1, 2) = -30 OBJECT(0, 0, 2, 0) = 30: OBJECT(0, 0, 2, 1) = -30: OBJECT(0, 0, 2, 2) = -30 OBJECT(0, 0, 3, 0) = 30: OBJECT(0, 0, 3, 1) = 30: OBJECT(0, 0, 3, 2) = -30 OBJECT(0, 0, 4, 0) = 0: OBJECT(0, 0, 4, 1) = 0: OBJECT(0, 0, 4, 2) = -30 ' PLANE 1 OBJECT(0, 1, 0, 0) = 30: OBJECT(0, 1, 0, 1) = 30: OBJECT(0, 1, 0, 2) = -30 OBJECT(0, 1, 1, 0) = 30: OBJECT(0, 1, 1, 1) = -30: OBJECT(0, 1, 1, 2) = -30 OBJECT(0, 1, 2, 0) = 30: OBJECT(0, 1, 2, 1) = -30: OBJECT(0, 1, 2, 2) = 30 OBJECT(0, 1, 3, 0) = 30: OBJECT(0, 1, 3, 1) = 30: OBJECT(0, 1, 3, 2) = 30 OBJECT(0, 1, 4, 0) = 30: OBJECT(0, 1, 4, 1) = 0: OBJECT(0, 1, 4, 2) = 0 ' PLANE 2 OBJECT(0, 2, 0, 0) = 30: OBJECT(0, 2, 0, 1) = 30: OBJECT(0, 2, 0, 2) = 30 OBJECT(0, 2, 1, 0) = 30: OBJECT(0, 2, 1, 1) = -30: OBJECT(0, 2, 1, 2) = 30 OBJECT(0, 2, 2, 0) = -30: OBJECT(0, 2, 2, 1) = -30: OBJECT(0, 2, 2, 2) = 30 OBJECT(0, 2, 3, 0) = -30: OBJECT(0, 2, 3, 1) = 30: OBJECT(0, 2, 3, 2) = 30 OBJECT(0, 2, 4, 0) = 0: OBJECT(0, 2, 4, 1) = 0: OBJECT(0, 2, 4, 2) = 30 ' PLANE 3 OBJECT(0, 3, 0, 0) = -30: OBJECT(0, 3, 0, 1) = 30: OBJECT(0, 3, 0, 2) = 30 OBJECT(0, 3, 1, 0) = -30: OBJECT(0, 3, 1, 1) = -30: OBJECT(0, 3, 1, 2) = 30 OBJECT(0, 3, 2, 0) = -30: OBJECT(0, 3, 2, 1) = -30: OBJECT(0, 3, 2, 2) = -30 OBJECT(0, 3, 3, 0) = -30: OBJECT(0, 3, 3, 1) = 30: OBJECT(0, 3, 3, 2) = -30 OBJECT(0, 3, 4, 0) = -30: OBJECT(0, 3, 4, 1) = 0: OBJECT(0, 3, 4, 2) = 0 ' PLANE 4 OBJECT(0, 4, 0, 0) = -30: OBJECT(0, 4, 0, 1) = -30: OBJECT(0, 4, 0, 2) = -30 OBJECT(0, 4, 1, 0) = -30: OBJECT(0, 4, 1, 1) = -30: OBJECT(0, 4, 1, 2) = 30 OBJECT(0, 4, 2, 0) = 30: OBJECT(0, 4, 2, 1) = -30: OBJECT(0, 4, 2, 2) = 30 OBJECT(0, 4, 3, 0) = 30: OBJECT(0, 4, 3, 1) = -30: OBJECT(0, 4, 3, 2) = -30 OBJECT(0, 4, 4, 0) = 0: OBJECT(0, 4, 4, 1) = -30: OBJECT(0, 4, 4, 2) = 0 ' PLANE 5 OBJECT(0, 5, 0, 0) = -30: OBJECT(0, 5, 0, 1) = 30: OBJECT(0, 5, 0, 2) = -30 OBJECT(0, 5, 1, 0) = 30: OBJECT(0, 5, 1, 1) = 30: OBJECT(0, 5, 1, 2) = -30 OBJECT(0, 5, 2, 0) = 30: OBJECT(0, 5, 2, 1) = 30: OBJECT(0, 5, 2, 2) = 30 OBJECT(0, 5, 3, 0) = -30: OBJECT(0, 5, 3, 1) = 30: OBJECT(0, 5, 3, 2) = 30 OBJECT(0, 5, 4, 0) = 0: OBJECT(0, 5, 4, 1) = 30: OBJECT(0, 5, 4, 2) = 0 ' SET UP PLANE [COLOR](COLOR.md)S ON CUBE ' PLANECOL(0) = 3 PLANECOL(1) = 4 PLANECOL(2) = 5 PLANECOL(3) = 6 PLANECOL(4) = 7 PLANECOL(5) = 8 ' [_TITLE](_TITLE.md) "QB64 _MAPTRIANGLE CUBE DEMO" [SCREEN](SCREEN.md) [_NEWIMAGE](_NEWIMAGE.md)(800, 600, 32) TextureImage& = [_LOADIMAGE](_LOADIMAGE.md)("qb64_trans.png") 'any 24/32 bit image '[_PUTIMAGE](_PUTIMAGE.md) , Image&  DO   ' LIMIT [TO](TO.md) 25 FPS   [_LIMIT](_LIMIT.md) 25   ' ERASE LAST IMAGE   [CLS](CLS.md)    ' CALCULATE POSITION OF NEW IMAGE   [FOR](FOR.md) OB& = 0 [TO](TO.md) 0 ' UP [TO](TO.md) 9 OBJECTS     SP = STAB(PIT(OB&)): CP = CTAB(PIT(OB&))     SY = STAB(YAW(OB&)): CY = CTAB(YAW(OB&))     SR = STAB(ROL(OB&)): CR = CTAB(ROL(OB&))     [FOR](FOR.md) PL& = 0 [TO](TO.md) 5 ' CONSISTING OF UP [TO](TO.md) 9 PLANES       '       [FOR](FOR.md) PN& = 0 [TO](TO.md) 3 ' EACH PLANE WITH UP [TO](TO.md) 4 [POINT](POINT.md)S (#5 [TO](TO.md) [PAINT](PAINT.md))         '         ' TRANSLATE, [THEN](THEN.md) ROTATE         TX& = OBJECT(OB&, PL&, PN&, 0)         TY& = OBJECT(OB&, PL&, PN&, 1)         TZ& = OBJECT(OB&, PL&, PN&, 2)         RX& = (TZ& * CP - TY& * SP) * SY - ((TZ& * SP + TY& * CP) * SR + TX& * CR) * CY         RY& = (TZ& * SP + TY& * CP) * CR - TX& * SR         RZ& = (TZ& * CP - TY& * SP) * CY + ((TZ& * SP + TY& * CP) * SR + TX& * CR) * SY         '         ' ROTATE, [THEN](THEN.md) TRANSLATE         RX& = RX& + MX&         RY& = RY& + MY&         RZ& = RZ& + MZ&         '         DPLANE3D(PN&, 0) = RX&: DPLANE3D(PN&, 1) = RY&: DPLANE3D(PN&, 2) = RZ&         DPLANE2D(PN&, 0) = 399 + (D& * RX& / RZ&)         DPLANE2D(PN&, 1) = 299 + (D& * RY& / RZ&)       [NEXT](NEXT.md)       '       ' CHECK [TO](TO.md) SEE [IF](IF.md) PLANE IS VISIBLE       x1& = DPLANE3D(0, 0): y1& = DPLANE3D(0, 1): Z1& = DPLANE3D(0, 2)       x2& = DPLANE3D(1, 0): y2& = DPLANE3D(1, 1): Z2& = DPLANE3D(1, 2)       x3& = DPLANE3D(2, 0): y3& = DPLANE3D(2, 1): Z3& = DPLANE3D(2, 2)       T1& = -x1& * (y2& * Z3& - y3& * Z2&)       T2& = x2& * (y3& * Z1& - y1& * Z3&)       T3& = x3& * (y1& * Z2& - y2& * Z1&)       '       VISIBLE& = T1& - T2& - T3&       [IF](IF.md) VISIBLE& > 0 [THEN](THEN.md)         ' DRAW PLANE         xx1% = DPLANE2D(0, 0): yy1% = DPLANE2D(0, 1)         xx2% = DPLANE2D(1, 0): yy2% = DPLANE2D(1, 1)         xx3% = DPLANE2D(2, 0): yy3% = DPLANE2D(2, 1)         col% = PLANECOL(PL&)          _MAPTRIANGLE (0, 0)-(0, 255)-(255, 255), TextureImage& TO(xx3%, yy3%)-(xx2%, yy2%)-(xx1%, yy1%)         ' CALL DrawTriangle(xx1%, yy1%, xx2%, yy2%, xx3%, yy3%, col%)         xx1% = DPLANE2D(0, 0): yy1% = DPLANE2D(0, 1)         xx3% = DPLANE2D(2, 0): yy3% = DPLANE2D(2, 1)         xx4% = DPLANE2D(3, 0): yy4% = DPLANE2D(3, 1)         _MAPTRIANGLE (0, 0)-(255, 255)-(255, 0), TextureImage& TO(xx3%, yy3%)-(xx1%, yy1%)-(xx4%, yy4%)         'CALL DrawTriangle(xx1%, yy1%, xx3%, yy3%, xx4%, yy4%, col%)       [END IF](END IF.md)     [NEXT](NEXT.md)     '     ' ROTATE OBJECT     PIT(OB&) = PIT(OB&) + 5     [IF](IF.md) PIT(OB&) > 359 [THEN](THEN.md) PIT(OB&) = 0     YAW(OB&) = YAW(OB&) + 7     [IF](IF.md) YAW(OB&) > 359 [THEN](THEN.md) YAW(OB&) = 0     ROL(OB&) = ROL(OB&) + 9     [IF](IF.md) ROL(OB&) > 359 [THEN](THEN.md) ROL(OB&) = 0   [NEXT](NEXT.md)   '   ' Calculate Frames per Second   frames% = frames% + 1   [IF](IF.md) oldtime$ <> [TIME$](TIME$.md) [THEN](THEN.md)     fps% = frames%     frames% = 1     oldtime$ = [TIME$](TIME$.md)   [END IF](END IF.md)   [COLOR](COLOR.md) [_RGB](_RGB.md)(255, 255, 255): [LOCATE](LOCATE.md) 1, 1: [PRINT](PRINT.md) "FPS :"; fps%   '   ' Show Image on Screen   [_DISPLAY](_DISPLAY.md) [LOOP](LOOP.md) [UNTIL](UNTIL.md) [INKEY$](INKEY$.md) <> "" [WIDTH](WIDTH.md) 80: [SCREEN](SCREEN.md) 0: [CLS](CLS.md)   [SUB](SUB.md) DrawHline (fromx%, tox%, yy%, col%)   '[DEF SEG](DEF SEG.md) = [&H](&H.md)A000   '[IF](IF.md) fromx% > tox% [THEN](THEN.md) [SWAP](SWAP.md) fromx%, tox%   'yyy& = yy%   'sloc& = yyy& * 320 + fromx%   'eloc& = sloc& + (tox% - fromx%)   '[FOR](FOR.md) t& = sloc& [TO](TO.md) eloc&   '  [POKE](POKE.md) t&, col%   '[NEXT](NEXT.md)   '[DEF SEG](DEF SEG.md)   [LINE](LINE.md) (fromx%, yy%)-(tox%, yy%), [_RGB](_RGB.md)(255, 255, 255) 'col% [END SUB](END SUB.md)  [SUB](SUB.md) DrawTriangle (x1%, y1%, x2%, y2%, x3%, y3%, col%)   DO     sflag% = 0     [IF](IF.md) y1% > y2% [THEN](THEN.md)       sflag% = 1       [SWAP](SWAP.md) y1%, y2%       [SWAP](SWAP.md) x1%, x2%     [END IF](END IF.md)     [IF](IF.md) y2% > y3% [THEN](THEN.md)       sflag% = 1       [SWAP](SWAP.md) y2%, y3%       [SWAP](SWAP.md) x2%, x3%     [END IF](END IF.md)   [LOOP](LOOP.md) [UNTIL](UNTIL.md) sflag% = 0   '   [IF](IF.md) y2% = y3% [THEN](THEN.md)     ' Draw a flat bottomed triangle     ydiff1% = y2% - y1%     ydiff2% = y3% - y1%     [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)       slope1! = (x2% - x1%) / ydiff1%     [ELSE](ELSE.md)       slope1! = 0     [END IF](END IF.md)     [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)       slope2! = (x3% - x1%) / ydiff2%     [ELSE](ELSE.md)       slope2! = 0     [END IF](END IF.md)     sx! = x1%: ex! = x1%     [FOR](FOR.md) y% = y1% [TO](TO.md) y2%       [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)       sx! = sx! + slope1!       ex! = ex! + slope2!     [NEXT](NEXT.md)     [EXIT SUB](EXIT SUB.md)   [ELSE](ELSE.md)     [IF](IF.md) y1% = y2% [THEN](THEN.md)       '       ' Draw a flat topped triangle       ydiff1% = y3% - y1%       ydiff2% = y3% - y2%       [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)         slope1! = (x3% - x1%) / ydiff1%       [ELSE](ELSE.md)         slope1! = 0       [END IF](END IF.md)       [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)         slope2! = (x3% - x2%) / ydiff2%       [ELSE](ELSE.md)         slope2! = 0       [END IF](END IF.md)       sx! = x1%: ex! = x2%       [FOR](FOR.md) y% = y1% [TO](TO.md) y3%         [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)         sx! = sx! + slope1!         ex! = ex! + slope2!       [NEXT](NEXT.md)       x1% = sx!: x2% = ex!       [EXIT SUB](EXIT SUB.md)     [ELSE](ELSE.md)       ' Draw a general purpose triangle       ' First draw the flat bottom portion (top half)       ydiff1% = y2% - y1%       ydiff2% = y3% - y1%       [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)         slope1! = (x2% - x1%) / ydiff1%       [ELSE](ELSE.md)         slope1! = 0       [END IF](END IF.md)       [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)         slope2! = (x3% - x1%) / ydiff2%       [ELSE](ELSE.md)         slope2! = 0       [END IF](END IF.md)       sx! = x1%: ex! = x1%       [FOR](FOR.md) y% = y1% [TO](TO.md) y2%         [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)         sx! = sx! + slope1!         ex! = ex! + slope2!       [NEXT](NEXT.md)       ' Then draw the flat topped portion (bottom half)       x1% = x2%       x2% = ex!       y1% = y2%       ydiff1% = y3% - y1%       ydiff2% = y3% - y2%       [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)         slope1! = (x3% - x1%) / ydiff1%       [ELSE](ELSE.md)         slope1! = 0       [END IF](END IF.md)       [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)         slope2! = (x3% - x2%) / ydiff2%       [ELSE](ELSE.md)         slope2! = 0       [END IF](END IF.md)       sx! = x1%: ex! = x2%       [FOR](FOR.md) y% = y1% [TO](TO.md) y3%         [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)         sx! = sx! + slope1!         ex! = ex! + slope2!       [NEXT](NEXT.md)       x1% = sx!: x2% = ex!     [END IF](END IF.md)   [END IF](END IF.md)   ' [END SUB](END SUB.md)  
```

  

*Example 3:* A 3D Spinning Cube demo using a hardware image and **QB64GL** hardware acceleration with _MAPTRIANGLE:

``` ' Copyright (C) 2011 by Andrew L. Ayers  [DIM](DIM.md) OBJECT(9, 9, 4, 2) [AS](AS.md) [LONG](LONG.md)  ' OBJECTS DEFINED [AS](AS.md) FOLLOWS: '   (#OBJECTS,#PLANES PER OBJECT,#[POINT](POINT.md)S PER PLANE, XYZ TRIPLE)  [DIM](DIM.md) DPLANE2D(4, 1) [AS](AS.md) [LONG](LONG.md) ' [SCREEN](SCREEN.md) PLANE COORDINATES  ' DPLANE2D DEFINED [AS](AS.md) FOLLOWS: '   (#[POINT](POINT.md)S PER PLANE, XY [DOUBLE](DOUBLE.md))  [DIM](DIM.md) DPLANE3D(4, 2) [AS](AS.md) [LONG](LONG.md) ' 3D PLANE COORDINATES  ' DPLANE3D DEFINED [AS](AS.md) FOLLOWS: '   (#[POINT](POINT.md)S PER PLANE, XYZ TRIPLE)  [DIM](DIM.md) PLANECOL(9) [AS](AS.md) [INTEGER](INTEGER.md) [DIM](DIM.md) STAB(359), CTAB(359) ' SINE/COSINE TABLES D& = 400: MX& = 0: MY& = 0: MZ& = -100 ' ' COMPUTE SINE/COSINE TABLES [FOR](FOR.md) t& = 0 [TO](TO.md) 359     STAB(t&) = [SIN](SIN.md)((6.282 / 360) * t&)     CTAB(t&) = [COS](COS.md)((6.282 / 360) * t&) [NEXT](NEXT.md) ' ' BUILD CUBE IN OBJECT ARRAY ' PLANE 0 OBJECT(0, 0, 0, 0) = -30: OBJECT(0, 0, 0, 1) = 30: OBJECT(0, 0, 0, 2) = -30 OBJECT(0, 0, 1, 0) = -30: OBJECT(0, 0, 1, 1) = -30: OBJECT(0, 0, 1, 2) = -30 OBJECT(0, 0, 2, 0) = 30: OBJECT(0, 0, 2, 1) = -30: OBJECT(0, 0, 2, 2) = -30 OBJECT(0, 0, 3, 0) = 30: OBJECT(0, 0, 3, 1) = 30: OBJECT(0, 0, 3, 2) = -30 OBJECT(0, 0, 4, 0) = 0: OBJECT(0, 0, 4, 1) = 0: OBJECT(0, 0, 4, 2) = -30 ' PLANE 1 OBJECT(0, 1, 0, 0) = 30: OBJECT(0, 1, 0, 1) = 30: OBJECT(0, 1, 0, 2) = -30 OBJECT(0, 1, 1, 0) = 30: OBJECT(0, 1, 1, 1) = -30: OBJECT(0, 1, 1, 2) = -30 OBJECT(0, 1, 2, 0) = 30: OBJECT(0, 1, 2, 1) = -30: OBJECT(0, 1, 2, 2) = 30 OBJECT(0, 1, 3, 0) = 30: OBJECT(0, 1, 3, 1) = 30: OBJECT(0, 1, 3, 2) = 30 OBJECT(0, 1, 4, 0) = 30: OBJECT(0, 1, 4, 1) = 0: OBJECT(0, 1, 4, 2) = 0 ' PLANE 2 OBJECT(0, 2, 0, 0) = 30: OBJECT(0, 2, 0, 1) = 30: OBJECT(0, 2, 0, 2) = 30 OBJECT(0, 2, 1, 0) = 30: OBJECT(0, 2, 1, 1) = -30: OBJECT(0, 2, 1, 2) = 30 OBJECT(0, 2, 2, 0) = -30: OBJECT(0, 2, 2, 1) = -30: OBJECT(0, 2, 2, 2) = 30 OBJECT(0, 2, 3, 0) = -30: OBJECT(0, 2, 3, 1) = 30: OBJECT(0, 2, 3, 2) = 30 OBJECT(0, 2, 4, 0) = 0: OBJECT(0, 2, 4, 1) = 0: OBJECT(0, 2, 4, 2) = 30 ' PLANE 3 OBJECT(0, 3, 0, 0) = -30: OBJECT(0, 3, 0, 1) = 30: OBJECT(0, 3, 0, 2) = 30 OBJECT(0, 3, 1, 0) = -30: OBJECT(0, 3, 1, 1) = -30: OBJECT(0, 3, 1, 2) = 30 OBJECT(0, 3, 2, 0) = -30: OBJECT(0, 3, 2, 1) = -30: OBJECT(0, 3, 2, 2) = -30 OBJECT(0, 3, 3, 0) = -30: OBJECT(0, 3, 3, 1) = 30: OBJECT(0, 3, 3, 2) = -30 OBJECT(0, 3, 4, 0) = -30: OBJECT(0, 3, 4, 1) = 0: OBJECT(0, 3, 4, 2) = 0 ' PLANE 4 OBJECT(0, 4, 0, 0) = -30: OBJECT(0, 4, 0, 1) = -30: OBJECT(0, 4, 0, 2) = -30 OBJECT(0, 4, 1, 0) = -30: OBJECT(0, 4, 1, 1) = -30: OBJECT(0, 4, 1, 2) = 30 OBJECT(0, 4, 2, 0) = 30: OBJECT(0, 4, 2, 1) = -30: OBJECT(0, 4, 2, 2) = 30 OBJECT(0, 4, 3, 0) = 30: OBJECT(0, 4, 3, 1) = -30: OBJECT(0, 4, 3, 2) = -30 OBJECT(0, 4, 4, 0) = 0: OBJECT(0, 4, 4, 1) = -30: OBJECT(0, 4, 4, 2) = 0 ' PLANE 5 OBJECT(0, 5, 0, 0) = -30: OBJECT(0, 5, 0, 1) = 30: OBJECT(0, 5, 0, 2) = -30 OBJECT(0, 5, 1, 0) = 30: OBJECT(0, 5, 1, 1) = 30: OBJECT(0, 5, 1, 2) = -30 OBJECT(0, 5, 2, 0) = 30: OBJECT(0, 5, 2, 1) = 30: OBJECT(0, 5, 2, 2) = 30 OBJECT(0, 5, 3, 0) = -30: OBJECT(0, 5, 3, 1) = 30: OBJECT(0, 5, 3, 2) = 30 OBJECT(0, 5, 4, 0) = 0: OBJECT(0, 5, 4, 1) = 30: OBJECT(0, 5, 4, 2) = 0 ' SET UP PLANE [COLOR](COLOR.md)S ON CUBE ' PLANECOL(0) = 3 PLANECOL(1) = 4 PLANECOL(2) = 5 PLANECOL(3) = 6 PLANECOL(4) = 7 PLANECOL(5) = 8 ' [_TITLE](_TITLE.md) "QB64 _MAPTRIANGLE CUBE DEMO" [SCREEN](SCREEN.md) [_NEWIMAGE](_NEWIMAGE.md)(800, 600, 32)  TextureImage& = [_LOADIMAGE](_LOADIMAGE.md)("qb64_trans.png", 32) 'any 24/32 bit image [_SETALPHA](_SETALPHA.md) 128, , TextureImage& TextureImage& = [_COPYIMAGE](_COPYIMAGE.md)(TextureImage&, 33)'copy of hardware image  '[_PUTIMAGE](_PUTIMAGE.md) , Image&  DO      ' LIMIT [TO](TO.md) 25 FPS     '[_LIMIT](_LIMIT.md) 25     ' [ERASE](ERASE.md) LAST IMAGE     '[CLS](CLS.md) , [_RGB](_RGB.md)(0, 0, 160)      ' CALCULATE POSITION OF NEW IMAGE     [FOR](FOR.md) OB& = 0 [TO](TO.md) 0 ' UP [TO](TO.md) 9 OBJECTS         SP = STAB(PIT(OB&)): CP = CTAB(PIT(OB&))         SY = STAB(YAW(OB&)): CY = CTAB(YAW(OB&))         SR = STAB(ROL(OB&)): CR = CTAB(ROL(OB&))         [FOR](FOR.md) PL& = 0 [TO](TO.md) 5 ' CONSISTING OF UP [TO](TO.md) 9 PLANES             '             [FOR](FOR.md) PN& = 0 [TO](TO.md) 3 ' EACH PLANE WITH UP [TO](TO.md) 4 [POINT](POINT.md)S (#5 [TO](TO.md) [PAINT](PAINT.md))                 '                 ' TRANSLATE, [THEN](THEN.md) ROTATE                 TX& = OBJECT(OB&, PL&, PN&, 0)                 TY& = OBJECT(OB&, PL&, PN&, 1)                 TZ& = OBJECT(OB&, PL&, PN&, 2)                 RX& = (TZ& * CP - TY& * SP) * SY - ((TZ& * SP + TY& * CP) * SR + TX& * CR) * CY                 RY& = (TZ& * SP + TY& * CP) * CR - TX& * SR                 RZ& = (TZ& * CP - TY& * SP) * CY + ((TZ& * SP + TY& * CP) * SR + TX& * CR) * SY                 '                 ' ROTATE, [THEN](THEN.md) TRANSLATE                 RX& = RX& + MX&                 RY& = RY& + MY&                 RZ& = RZ& + MZ&                 '                 DPLANE3D(PN&, 0) = RX&: DPLANE3D(PN&, 1) = RY&: DPLANE3D(PN&, 2) = RZ&                 DPLANE2D(PN&, 0) = 399 + (D& * RX& / RZ&)                 DPLANE2D(PN&, 1) = 299 + (D& * RY& / RZ&)             [NEXT](NEXT.md)             '             ' CHECK [TO](TO.md) SEE [IF](IF.md) PLANE [IS](IS.md) VISIBLE             x1& = DPLANE3D(0, 0): y1& = DPLANE3D(0, 1): Z1& = DPLANE3D(0, 2)             x2& = DPLANE3D(1, 0): y2& = DPLANE3D(1, 1): Z2& = DPLANE3D(1, 2)             x3& = DPLANE3D(2, 0): y3& = DPLANE3D(2, 1): Z3& = DPLANE3D(2, 2)             T1& = -x1& * (y2& * Z3& - y3& * Z2&)             T2& = x2& * (y3& * Z1& - y1& * Z3&)             T3& = x3& * (y1& * Z2& - y2& * Z1&)             '             VISIBLE& = T1& - T2& - T3&             [IF](IF.md) VISIBLE& > 0 [THEN](THEN.md)                 ' [DRAW](DRAW.md) PLANE                 xx1% = DPLANE2D(0, 0): yy1% = DPLANE2D(0, 1)                 xx2% = DPLANE2D(1, 0): yy2% = DPLANE2D(1, 1)                 xx3% = DPLANE2D(2, 0): yy3% = DPLANE2D(2, 1)                 col% = PLANECOL(PL&)                  [_BLEND](_BLEND.md) TextureImage&                 _MAPTRIANGLE (0, 0)-(0, 255)-(255, 255), TextureImage& TO(xx1%, yy1%)-(xx2%, yy2%)-(xx3%, yy3%)                  ' [CALL](CALL.md) DrawTriangle(xx1%, yy1%, xx2%, yy2%, xx3%, yy3%, col%)                 xx1% = DPLANE2D(0, 0): yy1% = DPLANE2D(0, 1)                 xx3% = DPLANE2D(2, 0): yy3% = DPLANE2D(2, 1)                 xx4% = DPLANE2D(3, 0): yy4% = DPLANE2D(3, 1)                  [_DONTBLEND](_DONTBLEND.md) TextureImage&                 _MAPTRIANGLE (0, 0)-(255, 255)-(255, 0), TextureImage& TO(xx3%, yy3%)-(xx1%, yy1%)-(xx4%, yy4%), , _SMOOTH                 '[CALL](CALL.md) DrawTriangle(xx1%, yy1%, xx3%, yy3%, xx4%, yy4%, col%)             [END IF](END IF.md)         [NEXT](NEXT.md)         '         ' ROTATE OBJECT         PIT(OB&) = PIT(OB&) + 5         [IF](IF.md) PIT(OB&) > 359 [THEN](THEN.md) PIT(OB&) = 0         YAW(OB&) = YAW(OB&) + 7         [IF](IF.md) YAW(OB&) > 359 [THEN](THEN.md) YAW(OB&) = 0         ROL(OB&) = ROL(OB&) + 9         [IF](IF.md) ROL(OB&) > 359 [THEN](THEN.md) ROL(OB&) = 0     [NEXT](NEXT.md)     '     ' Calculate Frames per Second     frames% = frames% + 1     [IF](IF.md) oldtime$ <> [TIME$](TIME$.md) [THEN](THEN.md)         fps% = frames%         frames% = 1         oldtime$ = [TIME$](TIME$.md)     [END IF](END IF.md)     [COLOR](COLOR.md) [_RGB](_RGB.md)(255, 255, 255): [LOCATE](LOCATE.md) 1, 1: [PRINT](PRINT.md) "FPS :"; fps%     '     ' Show Image on Screen     [_DISPLAY](_DISPLAY.md) [LOOP](LOOP.md) [UNTIL](UNTIL.md) [INKEY$](INKEY$.md) <> "" [WIDTH](WIDTH.md) 80: [SCREEN](SCREEN.md) 0: [CLS](CLS.md)  [SUB](SUB.md) DrawHline (fromx%, tox%, yy%, col%) '[DEF SEG](DEF SEG.md) = [&H](&H.md)A000 '[IF](IF.md) fromx% > tox% [THEN](THEN.md) [SWAP](SWAP.md) fromx%, tox% 'yyy& = yy% 'sloc& = yyy& * 320 + fromx% 'eloc& = sloc& + (tox% - fromx%) '[FOR](FOR.md) t& = sloc& [TO](TO.md) eloc& '  [POKE](POKE.md) t&, col% '[NEXT](NEXT.md) '[DEF SEG](DEF SEG.md) [LINE](LINE.md) (fromx%, yy%)-(tox%, yy%), [_RGB](_RGB.md)(255, 255, 255) 'col% [END SUB](END SUB.md)  [SUB](SUB.md) DrawTriangle (x1%, y1%, x2%, y2%, x3%, y3%, col%) DO     sflag% = 0     [IF](IF.md) y1% > y2% [THEN](THEN.md)         sflag% = 1         [SWAP](SWAP.md) y1%, y2%         [SWAP](SWAP.md) x1%, x2%     [END IF](END IF.md)     [IF](IF.md) y2% > y3% [THEN](THEN.md)         sflag% = 1         [SWAP](SWAP.md) y2%, y3%         [SWAP](SWAP.md) x2%, x3%     [END IF](END IF.md) [LOOP](LOOP.md) [UNTIL](UNTIL.md) sflag% = 0 ' [IF](IF.md) y2% = y3% [THEN](THEN.md)     ' Draw a flat bottomed triangle     ydiff1% = y2% - y1%     ydiff2% = y3% - y1%     [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)         slope1! = (x2% - x1%) / ydiff1%     [ELSE](ELSE.md)         slope1! = 0     [END IF](END IF.md)     [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)         slope2! = (x3% - x1%) / ydiff2%     [ELSE](ELSE.md)         slope2! = 0     [END IF](END IF.md)     sx! = x1%: ex! = x1%     [FOR](FOR.md) y% = y1% [TO](TO.md) y2%         [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)         sx! = sx! + slope1!         ex! = ex! + slope2!     [NEXT](NEXT.md)     [EXIT SUB](EXIT SUB.md) [ELSE](ELSE.md)     [IF](IF.md) y1% = y2% [THEN](THEN.md)         '         ' Draw a flat topped triangle         ydiff1% = y3% - y1%         ydiff2% = y3% - y2%         [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)             slope1! = (x3% - x1%) / ydiff1%         [ELSE](ELSE.md)             slope1! = 0         [END IF](END IF.md)         [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)             slope2! = (x3% - x2%) / ydiff2%         [ELSE](ELSE.md)             slope2! = 0         [END IF](END IF.md)         sx! = x1%: ex! = x2%         [FOR](FOR.md) y% = y1% [TO](TO.md) y3%             [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)             sx! = sx! + slope1!             ex! = ex! + slope2!         [NEXT](NEXT.md)         x1% = sx!: x2% = ex!         [EXIT SUB](EXIT SUB.md)     [ELSE](ELSE.md)         ' Draw a general purpose triangle         ' First draw the flat bottom portion (top half)         ydiff1% = y2% - y1%         ydiff2% = y3% - y1%         [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)             slope1! = (x2% - x1%) / ydiff1%         [ELSE](ELSE.md)             slope1! = 0         [END IF](END IF.md)         [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)             slope2! = (x3% - x1%) / ydiff2%         [ELSE](ELSE.md)             slope2! = 0         [END IF](END IF.md)         sx! = x1%: ex! = x1%         [FOR](FOR.md) y% = y1% [TO](TO.md) y2%             [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)             sx! = sx! + slope1!             ex! = ex! + slope2!         [NEXT](NEXT.md)         ' Then draw the flat topped portion (bottom half)         x1% = x2%         x2% = ex!         y1% = y2%         ydiff1% = y3% - y1%         ydiff2% = y3% - y2%         [IF](IF.md) ydiff1% <> 0 [THEN](THEN.md)             slope1! = (x3% - x1%) / ydiff1%         [ELSE](ELSE.md)             slope1! = 0         [END IF](END IF.md)         [IF](IF.md) ydiff2% <> 0 [THEN](THEN.md)             slope2! = (x3% - x2%) / ydiff2%         [ELSE](ELSE.md)             slope2! = 0         [END IF](END IF.md)         sx! = x1%: ex! = x2%         [FOR](FOR.md) y% = y1% [TO](TO.md) y3%             [CALL](CALL.md) DrawHline([CINT](CINT.md)(sx!), [CINT](CINT.md)(ex!), y%, col%)             sx! = sx! + slope1!             ex! = ex! + slope2!         [NEXT](NEXT.md)         x1% = sx!: x2% = ex!     [END IF](END IF.md) [END IF](END IF.md) ' [END SUB](END SUB.md)  
```

  

*Example 4:* Using a desktop image with _MAPTRIANGLE _ANTICLOCKWISE rendering.

``` [SCREEN](SCREEN.md) [_NEWIMAGE](_NEWIMAGE.md)(800, 600, 32)  ss32 = [_SCREENIMAGE](_SCREENIMAGE.md) 'take a 32bit software screenshot [_SETALPHA](_SETALPHA.md) 128, , ss32 'make it a bit transparent ss33 = [_COPYIMAGE](_COPYIMAGE.md)(ss32, 33) 'convert it to a hardware image (mode 33) [_FREEIMAGE](_FREEIMAGE.md) ss32 'we don't need this anymore  DO     [CLS](CLS.md) , [_RGB](_RGB.md)(0, 128, 255) 'use our software screen as a blue backdrop      'rotate our destination points     'the QB64 3D co-ordinate system is the same as  OpenGL's:     '    negative z is in front of you, if it doesn't have a negative z value you won't see it!     '    x goes from left to right, 0 is the middle of the screen     '    y goes from bottom to top, 0 is the middle of the screen     scale = 10     dist = -10     angle = angle + 0.1     x1 = [SIN](SIN.md)(angle) * scale     z1 = [COS](COS.md)(angle) * scale     x2 = [SIN](SIN.md)(angle + 3.14) * scale 'adding 3.14 adds 180 degrees     z2 = [COS](COS.md)(angle + 3.14) * scale     'what we performed above is a 2D/horizontal rotation of points     '(3D rotations are beyond the scope of this example)      'draw the triangle     '_ANTICLOCKWISE makes it only draw when our triangle is facing the correct direction     '_SMOOTH applies linear filtering to avoid a pixelated look      _MAPTRIANGLE **_ANTICLOCKWISE** ([_WIDTH](_WIDTH.md) "WIDTH (function)")(ss33) / 2, 0)-(0, [_HEIGHT](_HEIGHT.md)(ss33))-([_WIDTH](_WIDTH.md) "WIDTH (function)")(ss33),_     [_HEIGHT](_HEIGHT.md)(ss33)), ss33 TO(0, scale, dist)-(x1, -scale, z1 + dist)-(x2, -scale, z2 + dist), , **_SMOOTH**      [_LIMIT](_LIMIT.md) 30     [_DISPLAY](_DISPLAY.md) [LOOP](LOOP.md)  
```

**Tip:** If you are using Linux you might want to replace "[_SCREENIMAGE](_SCREENIMAGE.md)" with a [_LOADIMAGE](_LOADIMAGE.md) command if you don't see anything.
  

## See also

* [_PUTIMAGE](_PUTIMAGE.md)
* [_LOADIMAGE](_LOADIMAGE.md)
* [_COPYIMAGE](_COPYIMAGE.md)
* [GET (graphics statement)](GET (graphics statement).md) "GET (graphics statement)"), [PUT (graphics statement)](PUT (graphics statement).md) "PUT (graphics statement)")
* [STEP](STEP.md), [SIN](SIN.md), [COS](COS.md)
* [Hardware images](Hardware images.md)

  
