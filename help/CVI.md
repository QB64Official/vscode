# CVI

The CVI function decodes a 2-byte [STRING](STRING.md) generated by [MKI$](MKI$.md) (or read from a file) to [INTEGER](INTEGER.md) numeric values.

  

## Syntax

*result%* = CVI(*stringData$*)
  

## Description

* *CV* functions ([CVD](CVD.md), [CVS](CVS.md), CVI, [CVL](CVL.md), [CVDMBF](CVDMBF.md), [CVSMBF](CVSMBF.md)) are used to convert values encoded by *MK$* functions ([MKD$](MKD$.md), [MKS$](MKS$.md), [MKI$](MKI$.md), [MKL$](MKL$.md), [MKDMBF$](MKDMBF$.md), [MKSMBF$](MKSMBF$.md)).
* **QB64** has [_CV](_CV.md) and [_MK$](_MK$.md) functions which can also deal with extended [data types](data types.md).
* [INTEGER](INTEGER.md) values can range from -32768 to 32767.
* Doesn't return [_UNSIGNED](_UNSIGNED.md) values.

  

## Examples

*Example 1:*

``` [FIELD](FIELD.md) #1, 2 [AS](AS.md) N$, 12 [AS](AS.md) B$... [GET](GET.md) #1     'GET does not need a position or variable with successive FIELD buffer reads Y = CVI(N$)  
```

*Explanation:* Reads a field from file #1, and converts the first two bytes (N$) into an integer number assigned to the variable Y.
Since the representation of an integer number can use up to 5 ASCII characters (five bytes), writing to a file using [MKI$](MKI$.md) conversion, and then reading back with the CVI conversion can save up to 3 bytes of storage space.
  

*Example 2:* How CVI converts the ASCII code values created by the MKI$ function.

``` [SCREEN](SCREEN.md) 12 [DIM](DIM.md) Q [AS](AS.md) [STRING](STRING.md) * 1 Q = [CHR$](CHR$.md)(34) ' create Print using templates to align the values returned tmp1$ = "1st character code = ### * 1   =   ### " tmp2$ = "2nd character code = ### * 256 = ##### " tmp3$ = "                                 &  " tmp4$ = "                     CVI Total = ##### "  [DO](DO.md)   [COLOR](COLOR.md) 14: [LOCATE](LOCATE.md) 13, 20: [INPUT](INPUT.md) "Enter an Integer from 1 to 32767(0 quits): ", number%   [IF](IF.md) number% < 1 [THEN](THEN.md) [EXIT DO](EXIT DO.md)   [CLS](CLS.md)   ASCII$ = [MKI$](MKI$.md)(number%)     ' create the 2 byte character string   [COLOR](COLOR.md) 11   [_PRINTSTRING](_PRINTSTRING.md) (152, 240), "[MKI$](MKI$.md) creates 2 byte ASCII string: " + Q + ASCII$ + Q ' displays character(s)    asc1% = [ASC](ASC.md) "ASC (function)")(ASCII$)        ' find the ASCII code values of each character   asc2% = [ASC](ASC.md) "ASC (function)")(ASCII$, 2)     ' **QB64** allows ASC to read specific characters in a string    [LOCATE](LOCATE.md) 18, 20: [PRINT USING](PRINT USING.md) tmp1$; asc1%; asc1%   [LOCATE](LOCATE.md) 19, 20: [PRINT USING](PRINT USING.md) tmp2$; asc2%; asc2% * 256   [LOCATE](LOCATE.md) 20, 20: [PRINT USING](PRINT USING.md) tmp3$; "-----"   [LOCATE](LOCATE.md) 21, 20: [PRINT USING](PRINT USING.md) tmp4$; asc1% + (256 * asc2%) [LOOP](LOOP.md) [SYSTEM](SYSTEM.md)  
```

*Explanation:* All [ASCII](ASCII.md) characters can be displayed using [_PRINTSTRING](_PRINTSTRING.md) . The routine gets the [ASCII](ASCII.md) code, which is the actual value needed by CVI. The first byte code is always between 0 and 255. The second byte can return 0 thru 127 and CVI multiplies that value by 256. This proves that you cannot just feed a string number value to CVI and get the result desired. ("90" gets decoded to 12345).
  

## See also

* [Featured in our "Keyword of the Day" series](Featured in our "Keyword of the Day" series.md)
* [MKD$](MKD$.md), [MKI$](MKI$.md), [MKS$](MKS$.md), [MKL$](MKL$.md), [MKDMBF$](MKDMBF$.md), [MKSMBF$](MKSMBF$.md)
* [CVS](CVS.md), [CVD](CVD.md), [CVL](CVL.md), [CVSMBF](CVSMBF.md), [CVDMBF](CVDMBF.md)
* [_CV](_CV.md), [_MK$](_MK$.md)

  
